#!/usr/bin/env python3
from fractions import gcd
import argparse
import secrets
import random
import hashlib
import sys
import pickle

from copy import deepcopy


class Key:
	PRIVATE_INFO = ['P', 'Q', 'D', 'DmP1', 'DmQ1']
	def __init__(self, **kwargs):
		for k, v in kwargs.items():
			setattr(self, k, v)
		assert self.bits % 8 == 0

	def ispub(self):
		return all(not hasattr(self, key) for key in self.PRIVATE_INFO)

	def ispriv(self):
		return all(hasattr(self, key) for key in self.PRIVATE_INFO)

	def pub(self):
		p = deepcopy(self)
		for key in self.PRIVATE_INFO:
			if hasattr(p, key):
				delattr(p, key)
		return p

	def priv(self):
		raise NotImplementedError()


def genprime(bits):
	while True:
		p = secrets.randbits(bits-1) | (1 << (bits-1))
		if isprime(p): return p

def isprime(n):
	return n > 1 and miller_rabin(n)

def miller_rabin(n, rounds=50):
	assert n > 1
	if not (n & 1): return n == 2
	if n < 15: return n != 9
	d, r = n-1, 0
	while not (d & 1):
		d >>= 1
		r += 1
	assert (d & 1) == 1 and d << r == n-1
	for _ in range(rounds):	
		x = pow(random.randrange(2, n-1), d, n)
		if x == 1 or x == n-1: continue
		for i in range(1, r):
			x = x * x % n
			if x == n-1: break
		else:
			return False
	return True

def egcd(a1, a2):
	x1, x2 = 1, 0
	y1, y2 = 0, 1
	while a2:
		q = a1 // a2
		a1, a2 = a2, a1 - q * a2
		x1, x2 = x2, x1 - q * x2
		y1, y2 = y2, y1 - q * y2
	return (x1, y1, a1)

def genkey(p, q):
	while True:
		e = 65537
		d, _, g = egcd(e, (p-1) * (q-1))
		if g != 1: continue
		iQmP, iPmQ, _ = egcd(q, p)
		return Key(
			N=p*q, P=p, Q=q, E=e, D=d%((p-1)*(q-1)), DmP1=d%(p-1), DmQ1=d%(q-1),
			iQmP=iQmP%p, iPmQ=iPmQ%q, bits=4096,
		)


def bytes2num(data):
	return sum(x << (8 * i) for i, x in enumerate(data))

def num2bytes(data, size):
	assert 0 <= data and (data >> (size * 8)) == 0
	return bytes(data >> (8 * i) & 0xff for i in range(size))

def xor(d1, d2):
	return bytes(
		d1[i % len(d1)] ^ d2[i % len(d2)]
		for i in range(max(len(d1), len(d2)))
	)


def random_oracle(source, length, hash=hashlib.sha256):
	return b''.join(
		hash(source + num2bytes(idx, 4)).digest()
		for idx in range((length - 1) // hash().digest_size + 1)
	)[:length]

def pad(data, bits, hash=hashlib.sha256):
	k = hash().digest_size
	Xlen = (bits - 1) // 8 - k
	assert len(data) + k <= Xlen
	X = data.ljust(Xlen, b'\x00')
	Y = num2bytes(secrets.randbits(k * 8), k)
	X = xor(X, random_oracle(Y, Xlen, hash))
	Y = xor(Y, random_oracle(X, k, hash))
	return X + Y + b'\x00'

def unpad(data, hash=hashlib.sha256):
	if data[-1] != 0: return None
	data = data[:-1]

	k = hash().digest_size
	Xlen = len(data) - k
	X, Y = data[:Xlen], data[-k:]
	Y = xor(Y, random_oracle(X, k, hash))
	X = xor(X, random_oracle(Y, Xlen, hash))
	if all(b == 0 for b in X[-k:]):
		return X[:-k]
	return None


def encrypt(key, data):
	data = bytes2num(pad(data, key.bits))
	assert 0 <= data and data < key.N
	data = pow(data, key.E, key.N)
	return num2bytes(data, key.bits // 8)

def decrypt(key, data):
	assert key.ispriv() and len(data) * 8 == key.bits
	data = bytes2num(data)
	assert 0 <= data and data < key.N
	v1 = pow(data, key.DmP1, key.P)
	v2 = pow(data, key.DmQ1, key.Q)
	data = (v2 * key.P * key.iPmQ + v1 * key.Q * key.iQmP) % key.N
	return unpad(num2bytes(data, key.bits // 8))


def action_decrypt(args):
	data = args.i.read()
	data = decrypt(args.k, data)
	if data is None:
		print('Failed to decrypt', file=sys.stderr)
		exit(1)
	args.o.write(data)

def action_encrypt(args):
	data = args.i.read()
	data = encrypt(args.k, data)
	args.o.write(data)

def action_keygen(p, q, priv_file, pub_file):
	key = genkey(p, q)
	pickle.dump(key, priv_file)
	pickle.dump(key.pub(), pub_file)


def keysize(string):
	try:
		value = int(string)
	except ValueError:
		raise argparse.ArgumentTypeError(f'{string:r} is not a number')
	if value % 8:
		raise argparse.ArgumentTypeError(f'{value} must be a multiple of 8')
	if 256 <= value and value < 8192:
		return value
	raise argparse.ArgumentTypeError(f'{value} out of range')

def keyfile(private=False):
	def func(string):
		f = argparse.FileType('rb')(string)
		key = pickle.load(f)
		if not isinstance(key, Key):
			raise argparse.ArgumentTypeError(f'{string:r} did not specify a valid key')
		if private and not key.ispriv():
			raise argparse.ArgumentTypeError(f'{string:r} did not specify a private key')
		return key
	return func

def print_priv_info(key):
	print("bits : " + str(key.bits))
	print("N : " + str(key.N))
	print("P : " + str(key.P))
	print("Q : " + str(key.Q))
	print("E : " + str(key.E))
	print("D : " + str(key.D))
	print("DmP1 : " + str(key.DmP1))
	print("DmQ1 : " + str(key.DmQ1))
	print("iQmP : " + str(key.iQmP))
	print("iPmQ : " + str(key.iPmQ))
	
def print_pub_info(key):
	print("bits : " + str(key.bits))
	print("N : " + str(key.N))
	print("E : " + str(key.E))
	print("iQmP : " + str(key.iQmP))
	print("iPmQ : " + str(key.iPmQ))

def main():
	with open('key.sad.pub', 'rb') as f:
		key = pickle.load(f)
	n = key.N
	a_px = key.iQmP
	b_qy = key.iPmQ
	A = a_px
	B = b_qy
	
	p = 31659077809885706699482361830477717572837081779677626435829903374921581240849180063108552019274021826092781287218568613206006085334956822705610578514426596962412655157776833178744403034727698399320215892200440936975683502329350531806920697009386909154114556681774784614085691096050135180228131842452179315216957730905902673882170120973148157907231188547167482558383495097819905373068326760590890291412820411304614611983343203819383860434964843931325658872603238498210722446318497674396725811567139923114789843056157733621133155720503541819498078610854651245426825738313809229403279974283490718799392611854934535622307
	q = 25004672227855409995386175663336188685177638541286666056441830847618100808198668167307814236224429885295241140194633625051478252429462828073782848889819460674774292004752724556602147320684206242726073358822655212944688523823150236245522627662371134165404316388528738697090763677910441487876514668914442018764569771021916503649822836288868439220382922721194436569302106969570041514638164319835688101248578648742016186666021527781591528560611986692317045407081396778512783312692838307769559661780971287324753785154074832628454871505400166651610503632212720604214996108967812794633118832616768643612648168060802523582631
	
	with open('key.sad.pub', 'rb') as f:
		key = pickle.load(f)
	
	priv = open("attack.priv", 'wb')
	pub = open("attack.pub", 'wb')
	action_keygen(p,q, 	priv, pub)
	

if __name__ == '__main__': 
	main()


